Index: api/config.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import yaml,requests,os\r\nfrom datetime import datetime\r\ndef params():#从yaml读取参数后，转换格式\r\n    with open('testcase.yaml', 'r') as f:\r\n        y = yaml.unsafe_load(f)\r\n    l = []\r\n    for i in y.values():\r\n        l.append(tuple(i.values()))\r\n    return l\r\n\r\n#封装request方法\r\ncookie=None\r\nclass Request():\r\n    def __init__(self,mothod,url,header=None,params=None,body=None):\r\n        self.mothod=mothod\r\n        self.url=url\r\n        self.header=header\r\n        self.params=params\r\n        self.body=body\r\n        # if not cookie:\r\n        #     self.cookie=Request.get_cookie(self)\r\n    def get_cookie(self):\r\n        response=requests.request(self.mothod,url=self.url,headers=self.header,params=self.params,data=self.body)\r\n        return response.cookies\r\n    def get_response(self):\r\n        response=requests.request(self.mothod,url=self.url,headers=self.header,params=self.params,data=self.body)\r\n        return response\r\n\r\n#获取现在的时间：string（年-月-日）\r\ndef time_Now():\r\n    return datetime.now().strftime('%y-%m-%d')\r\n\r\n#获取主目录绝对路径or当前文件名 （func[0]or[1]）\r\ndef main_Path():\r\n    return os.path.split(os.path.abspath(__file__))\r\ndef request_param():\r\n        pass\r\ndef read_Config():\r\n    return time_Now()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/api/config.py b/api/config.py
--- a/api/config.py	(revision e27b689963a9f16e3f9e61693d73bf6ce1cdb90b)
+++ b/api/config.py	(date 1633675813547)
@@ -1,13 +1,12 @@
 import yaml,requests,os
 from datetime import datetime
 def params():#从yaml读取参数后，转换格式
-    with open('testcase.yaml', 'r') as f:
+    with open('testcase.yaml', 'r',encoding='utf8') as f:
         y = yaml.unsafe_load(f)
     l = []
     for i in y.values():
         l.append(tuple(i.values()))
     return l
-
 #封装request方法
 cookie=None
 class Request():
Index: 1.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># import time\r\n#\r\n# def hello():\r\n#     time.sleep(1)\r\n#\r\n# def run():\r\n#     for i in range(5):\r\n#         hello()\r\n#         print('Hello World:%s' % time.time())  # 任何伟大的代码都是从Hello World 开始的！\r\n# if __name__ == '__main__':\r\n#     run()\r\n# import time\r\n# import asyncio\r\n#\r\n# # 定义异步函数\r\n# async def hello():\r\n#     print('Hello World:%s' % time.time())\r\n#     print('Hello World1:%s' % time.time())\r\n#\r\n# def run():\r\n#     for i in range(5):\r\n#         loop.run_until_complete(hello())\r\n#\r\n# loop = asyncio.get_event_loop()\r\n# if __name__ =='__main__':\r\n#     run()\r\n# def coroutine_example(name):\r\n#     print('start coroutine...name:', name)\r\n#     x = yield name #调用next()时，产出yield右边的值后暂停；调用send()时，产出值赋给x，并往下运行\r\n#     print('send值:', x)\r\n#     return 'zhihuID: Zarten'\r\n#\r\n# def grouper2():\r\n#     result2 = yield from coroutine_example('Zarten') #在此处暂停，等待子生成器的返回后继续往下执行\r\n#     print('result2的值：', result2)\r\n#     return result2\r\n#\r\n# def grouper():\r\n#     result = yield from grouper2() #在此处暂停，等待子生成器的返回后继续往下执行\r\n#     print('result的值：', result)\r\n#     return result\r\n#\r\n# def main():\r\n#     g = grouper()\r\n#     next(g)\r\n#     print(\"我继续执行了\")\r\n#     try:\r\n#         g.send(10)\r\n#     except StopIteration as e:\r\n#         print('返回值：', e.value)\r\n#\r\n# if __name__ == '__main__':\r\n#     main()\r\n# import asyncio\r\n# def my_callback(future):\r\n#     print('返回值：', future.result())\r\n# async def coroutine_example():\r\n#     await asyncio.sleep(5)\r\n#     return 'result'\r\n# loop = asyncio.get_event_loop()\r\n# coro = coroutine_example()\r\n# task=loop.create_task(coro)\r\n# print(\"等待请求回来\")\r\n# task.add_done_callback(my_callback)\r\n# loop.run_until_complete(coro)\r\n# loop.close()\r\n# import asyncio\r\nimport threading\r\n\r\n# import mysql\r\n# loop=asyncio.get_event_loop()\r\n# async def a():\r\n#     return 123\r\n# async def select():\r\n#     s = mysql.Database('47.101.53.77', 'root', 'ppaa1122', 'test')\r\n#     task=await s.select_Mysql('select * from t_student',1)\r\n#\r\n# loop.run_until_complete(select())\r\n# import threading\r\n# import asyncio\r\n# async def xc():\r\n#     print('12321313123')\r\n# async def hello():\r\n#     print('Hello world! (%s)' % threading.currentThread())\r\n#     r=await xc()\r\n#     await asyncio.sleep(2)\r\n#     print('Hello again! (%s)' % threading.currentThread())\r\n# loop = asyncio.get_event_loop()\r\n# loop.run_until_complete(hello())\r\n# loop.close()\r\nimport asyncio\r\nimport time\r\n# async def a(x):\r\n#     await asyncio.sleep(x)\r\n#     print('我在运行a%s'%x)\r\n# async def b(x):\r\n#     await asyncio.sleep(x)\r\n#     print('我在运行b%s'%x)\r\n# async def main():\r\n#     n=time.time()\r\n#     task=asyncio.create_task(a(2))\r\n#     results=await asyncio.gather(a(1),b(5),a(3),a(4),a(5),task)\r\n#     s=time.time()-n\r\n#     return s\r\n# print(asyncio.run(main()))\r\n# import asyncio\r\n# from datetime import datetime\r\n#\r\n# import aiohttp\r\n# from lxml import etree\r\n# headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit\"\r\n#                          \"/537.36 (KHTML, like Gecko) \"\r\n#                          \"Chrome/72.0.3626.121 Safari/537.36\"}\r\n#\r\n#\r\n# async def get_movie_url():\r\n#     req_url = \"https://movie.douban.com/chart\"\r\n#     async with aiohttp.ClientSession(headers=headers) as session:\r\n#         async with session.get(url=req_url, headers=headers) as response:\r\n#             result = await response.text()\r\n#             result = etree.HTML(result)\r\n#             print(result.xpath(\"//*[@id='content']/div/div[1]/div/div/table/tr/td/a/@href\"))\r\n#         return result.xpath(\"//*[@id='content']/div/div[1]/div/div/table/tr/td/a/@href\")\r\n#\r\n#\r\n# async def get_movie_content(movie_url):\r\n#     async with aiohttp.ClientSession(headers=headers) as session:\r\n#         async with session.get(url=movie_url, headers=headers) as response:\r\n#             result = await response.text()\r\n#             result = etree.HTML(result)\r\n#         movie = dict()\r\n#         name = result.xpath('//*[@id=\"content\"]/h1/span[1]//text()')\r\n#         author = result.xpath('//*[@id=\"info\"]/span[1]/span[2]//text()')\r\n#         movie[\"name\"] = name\r\n#         movie[\"author\"] = author\r\n#     return movie\r\n#\r\n# if __name__ == '__main__':\r\n#     start = datetime.now()\r\n#     loop = asyncio.get_event_loop()\r\n#     movie_url_list = loop.run_until_complete(get_movie_url())\r\n#     tasks = [get_movie_content(url) for url in movie_url_list]\r\n#     movies = loop.run_until_complete(asyncio.gather(*tasks))\r\n#     print(movies)\r\n#     print(\"异步用时为：{}\".format(datetime.now() - start))\r\n# import yaml\r\n# y='''\r\n# name: 回来\r\n# age: 0\r\n# job: 12\r\n# '''\r\n# y=yaml.unsafe_load(y)\r\n# with open('api/testcase.yaml', 'r') as f:\r\n#     s=yaml.unsafe_load(f)\r\n# print(y)\r\n# print(s)\r\n# import threading\r\n# s=2\r\n# lock=threading.Lock()\r\n# def run(n):\r\n#     global s\r\n#     for i in range(1,n):\r\n#         lock.acquire()\r\n#         s*=s\r\n#         print(s)\r\n#         lock.release()\r\n# def run1(n):\r\n#     global s\r\n#     for i in range(1,n):\r\n#         lock.acquire()\r\n#         s/=s\r\n#         print(s)\r\n#         lock.release()\r\n# a=threading.Thread(target=run,args=(100,))\r\n# b=threading.Thread(target=run1,args=(100,))\r\n# a.start()\r\n# b.start()\r\n# a.join()\r\n# b.join()\r\n# from collections import deque\r\n# a=deque()\r\n# a.append('1')\r\n# a.append('1')\r\n# a.append('1')\r\n# a.append('1')\r\n# a.appendleft('2')\r\n# a.pop()\r\n# print(a)\r\n# import random, time, queue\r\n# from multiprocessing.managers import BaseManager\r\n#\r\n# # 发送任务的队列:\r\n#\r\n# # 接收结果的队列:\r\n# result_queue = queue.Queue()\r\n#\r\n# # 从BaseManager继承的QueueManager:\r\n# class QueueManager(BaseManager):\r\n#     pass\r\n# def task_quque():\r\n#     task_queue = queue.Queue()\r\n#     return task_queue\r\n# # 把两个Queue都注册到网络上, callable参数关联了Queue对象:\r\n# QueueManager.register('get_task_queue',task_queue())\r\n# QueueManager.register('get_result_queue', callable=lambda: result_queue)\r\n# # 绑定端口5000, 设置验证码'abc':\r\n# manager = QueueManager(address=('', 5000), authkey=b'abc')\r\n# # 启动Queue:\r\n# manager.start()\r\n# # 获得通过网络访问的Queue对象:\r\n# task = manager.get_task_queue()\r\n# result = manager.get_result_queue()\r\n# # 放几个任务进去:\r\n# for i in range(10):\r\n#     n = random.randint(0, 10000)\r\n#     print('Put task %d...' % n)\r\n#     task.put(n)\r\n# # 从result队列读取结果:\r\n# print('Try get results...')\r\n# for i in range(10):\r\n#     r = result.get(timeout=10)\r\n#     print('Result: %s' % r)\r\n# # 关闭:\r\n# manager.shutdown()\r\n# print('master exit.')#!/usr/bin/env python3\r\n# # -*- coding: utf-8 -*-\r\n#\r\n# import random,time,queue\r\n# from multiprocessing.managers import BaseManager\r\n# #发送任务队列\r\n# task_queue=queue.Queue()\r\n# #接收结果队列\r\n# result_queue=queue.Queue()\r\n#\r\n# #继承BaseManager\r\n# class QueueManager(BaseManager):\r\n#     pass\r\n# def return_task_queue():\r\n#     #global 用于函数内部，修改全局变量的值\r\n#     global task_queue\r\n#     return task_queue\r\n# def return_result_queue():\r\n#     global result_queue\r\n#     return result_queue\r\n# if __name__=='__main__':\r\n#     #将两个Queue注册到网络上，callable参数关联Queue对象\r\n#     #！win10中callale不对lambda匿名函数做处理\r\n#     QueueManager.register('get_task_queue',callable=return_task_queue)\r\n#     QueueManager.register('get_result_queue',callable=return_result_queue)\r\n#     #绑定端口5000，这5000怎么来的？两个文件中的端口一样就行！，设置验证码abc\r\n#     #通过QueueManager将Queue暴露出去\r\n#     manager=QueueManager(address=('127.0.0.1',5000),authkey=b'abc')\r\n#     manager.start()\r\n#     task=manager.get_task_queue()\r\n#     result=manager.get_result_queue()\r\n#     #放10个任务进去\r\n#     for i in range(10):\r\n#         n=random.randint(0,1000)\r\n#         print('Put task %d...'%n)\r\n#         #将数据放到任务队列\r\n#         task.put(n)\r\n#     #取任务执行结果\r\n#     print('Try get results...')\r\n#     for i in range(10):\r\n#         #从结果队列中取结果\r\n#         #等待10是因为计算需要时间\r\n#         r=result.get(timeout=10)\r\n#         print('REsult:%s'%r)\r\n#     #关闭\r\n#     manager.shutdown()\r\n#     print('master end')\r\nimport openpyxl\r\nf=openpyxl.open('1.xlsx')\r\nsheet=f.worksheets[0]\r\nf.create_named_range('qwe',sheet)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/1.py b/1.py
--- a/1.py	(revision e27b689963a9f16e3f9e61693d73bf6ce1cdb90b)
+++ b/1.py	(date 1633685918896)
@@ -269,7 +269,103 @@
 #     #关闭
 #     manager.shutdown()
 #     print('master end')
-import openpyxl
-f=openpyxl.open('1.xlsx')
-sheet=f.worksheets[0]
-f.create_named_range('qwe',sheet)
\ No newline at end of file
+# import logging
+# # logging.basicConfig(filename='1.log',filemode='w',level=logging.DEBUG)
+# log=logging.getLogger('测试')
+# for i in range(1,10):
+#    log.debug('正在运行{}'.format(i))
+# async def blocking_io3():
+#    print('测试3')
+#    return '23222223'
+# def blocking_io():
+#    print('测试1')
+#    return '2323'
+# async def blocking_io1():
+#    s=await blocking_io3()
+#    print('测试2')
+#    return s
+# async def main():
+#    print(f"started main at {time.strftime('%X')}")
+#    task1=asyncio.create_task(blocking_io1())
+#    task2=asyncio.to_thread(blocking_io)
+#    await asyncio.gather(task1,
+#       task2
+#       )
+#    print(task1.result())
+#
+#    print(f"finished main at {time.strftime('%X')}")
+#
+#
+# asyncio.run(main())
+# def consumer():
+#    r = ''
+#    while True:
+#       n = yield r
+#       if not n:
+#          return
+#       print('[CONSUMER] Consuming %s...' % n)
+#       r = '200 OK'
+#
+#
+# def produce(c):
+#    c.send(None)
+#    n = 0
+#    while n < 5:
+#       n = n + 1
+#       print('[PRODUCER] Producing %s...' % n)
+#       r = c.send(n)
+#       print('[PRODUCER] Consumer return: %s' % r)
+#    c.close()
+#
+#
+# c = consumer()
+# produce(c)
+import threading,os
+s=threading.local()
+def demo():
+   print('正在运行%s'% s.ss)
+def main(a):
+   s.ss=a
+   demo()
+a=threading.Thread(target=main,args=(1,))
+b=threading.Thread(target=main,args=(2,))
+a.start()
+b.start()
+q=os.path.abspath(__file__)
+print(__file__)
+print(q)
+print(os.path.dirname(q))
+# from PIL import Image, ImageDraw, ImageFont, ImageFilter
+#
+# import random
+#
+# # 随机字母:
+# def rndChar():
+#     return chr(random.randint(65, 90))
+#
+# # 随机颜色1:
+# def rndColor():
+#     return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))
+#
+# # 随机颜色2:
+# def rndColor2():
+#     return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))
+#
+# # 240 x 60:
+# width = 60 * 4
+# height = 60
+# image = Image.new('RGB', (width, height), (255, 255, 255))
+# # 创建Font对象:
+# font = ImageFont.truetype('C:\Windows\Fonts\Arial.ttf', 36)
+# # 创建Draw对象:
+# draw = ImageDraw.Draw(image)
+# # 填充每个像素:
+# for x in range(width):
+#     for y in range(height):
+#         draw.point((x, y), fill=rndColor())
+# # 输出文字:
+# for t in range(4):
+#     draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())
+# # 模糊:
+# image = image.filter(ImageFilter.BLUR)
+# image.save('code.jpg', 'jpeg')
\ No newline at end of file
Index: api/testcase.yaml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#用例写在这里↓↓↓\r\ntest1:\r\n  method: get\r\n  url: http://www.baidu.com\r\n  status_code: 200\r\ntest2:\r\n  method: get\r\n  url: http://www.hao123.com\r\n  status_code: 200\r\ntest3:\r\n  method: get\r\n  url: http://www.163.com\r\n  status_code: 200\r\ntest4:\r\n  method: get\r\n  url: http://www.qq.com\r\n  status_code: 200\r\ntest5:\r\n  method: get\r\n  url: http://www.taobao.com\r\n  status_code: 200\r\ntest6:\r\n  method: get\r\n  url: http://www.jd.com\r\n  status_code: 200\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/api/testcase.yaml b/api/testcase.yaml
--- a/api/testcase.yaml	(revision e27b689963a9f16e3f9e61693d73bf6ce1cdb90b)
+++ b/api/testcase.yaml	(date 1633675441768)
@@ -22,4 +22,4 @@
 test6:
   method: get
   url: http://www.jd.com
-  status_code: 200
+  status_code: 200
\ No newline at end of file
Index: pytestDemo-master/core/rest_client.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import requests\r\nimport json as complexjson\r\nfrom common.logger import logger\r\n\r\n\r\nclass RestClient():\r\n\r\n    def __init__(self, api_root_url):\r\n        self.api_root_url = api_root_url\r\n        self.session = requests.session()\r\n\r\n    def get(self, url, **kwargs):\r\n        return self.request(url, \"GET\", **kwargs)\r\n\r\n    def post(self, url, data=None, json=None, **kwargs):\r\n        return self.request(url, \"POST\", data, json, **kwargs)\r\n\r\n    def put(self, url, data=None, **kwargs):\r\n        return self.request(url, \"PUT\", data, **kwargs)\r\n\r\n    def delete(self, url, **kwargs):\r\n        return self.request(url, \"DELETE\", **kwargs)\r\n\r\n    def patch(self, url, data=None, **kwargs):\r\n        return self.request(url, \"PATCH\", data, **kwargs)\r\n\r\n    def request(self, url, method, data=None, json=None, **kwargs):\r\n        url = self.api_root_url + url\r\n        headers = dict(**kwargs).get(\"headers\")\r\n        params = dict(**kwargs).get(\"params\")\r\n        files = dict(**kwargs).get(\"params\")\r\n        cookies = dict(**kwargs).get(\"params\")\r\n        self.request_log(url, method, data, json, params, headers, files, cookies)\r\n        if method == \"GET\":\r\n            return self.session.get(url, **kwargs)\r\n        if method == \"POST\":\r\n            return requests.post(url, data, json, **kwargs)\r\n        if method == \"PUT\":\r\n            if json:\r\n                # PUT 和 PATCH 中没有提供直接使用json参数的方法，因此需要用data来传入\r\n                data = complexjson.dumps(json)\r\n            return self.session.put(url, data, **kwargs)\r\n        if method == \"DELETE\":\r\n            return self.session.delete(url, **kwargs)\r\n        if method == \"PATCH\":\r\n            if json:\r\n                data = complexjson.dumps(json)\r\n            return self.session.patch(url, data, **kwargs)\r\n\r\n    def request_log(self, url, method, data=None, json=None, params=None, headers=None, files=None, cookies=None, **kwargs):\r\n        logger.info(\"接口请求地址 ==>> {}\".format(url))\r\n        logger.info(\"接口请求方式 ==>> {}\".format(method))\r\n        # Python3中，json在做dumps操作时，会将中文转换成unicode编码，因此设置 ensure_ascii=False\r\n        logger.info(\"接口请求头 ==>> {}\".format(complexjson.dumps(headers, indent=4, ensure_ascii=False)))\r\n        logger.info(\"接口请求 params 参数 ==>> {}\".format(complexjson.dumps(params, indent=4, ensure_ascii=False)))\r\n        logger.info(\"接口请求体 data 参数 ==>> {}\".format(complexjson.dumps(data, indent=4, ensure_ascii=False)))\r\n        logger.info(\"接口请求体 json 参数 ==>> {}\".format(complexjson.dumps(json, indent=4, ensure_ascii=False)))\r\n        logger.info(\"接口上传附件 files 参数 ==>> {}\".format(files))\r\n        logger.info(\"接口 cookies 参数 ==>> {}\".format(complexjson.dumps(cookies, indent=4, ensure_ascii=False)))\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pytestDemo-master/core/rest_client.py b/pytestDemo-master/core/rest_client.py
--- a/pytestDemo-master/core/rest_client.py	(revision e27b689963a9f16e3f9e61693d73bf6ce1cdb90b)
+++ b/pytestDemo-master/core/rest_client.py	(date 1631876559588)
@@ -50,10 +50,11 @@
     def request_log(self, url, method, data=None, json=None, params=None, headers=None, files=None, cookies=None, **kwargs):
         logger.info("接口请求地址 ==>> {}".format(url))
         logger.info("接口请求方式 ==>> {}".format(method))
-        # Python3中，json在做dumps操作时，会将中文转换成unicode编码，因此设置 ensure_ascii=False
         logger.info("接口请求头 ==>> {}".format(complexjson.dumps(headers, indent=4, ensure_ascii=False)))
         logger.info("接口请求 params 参数 ==>> {}".format(complexjson.dumps(params, indent=4, ensure_ascii=False)))
         logger.info("接口请求体 data 参数 ==>> {}".format(complexjson.dumps(data, indent=4, ensure_ascii=False)))
         logger.info("接口请求体 json 参数 ==>> {}".format(complexjson.dumps(json, indent=4, ensure_ascii=False)))
         logger.info("接口上传附件 files 参数 ==>> {}".format(files))
         logger.info("接口 cookies 参数 ==>> {}".format(complexjson.dumps(cookies, indent=4, ensure_ascii=False)))
+
+        # Python3中，json在做dumps操作时，会将中文转换成unicode编码，因此设置 ensure_ascii=False
\ No newline at end of file
Index: client.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import aiohttp\r\nimport asyncio\r\n\r\nasync def fetch(session, url):\r\n    async with session.get(url) as response:\r\n        return await response.text()\r\n\r\nasync def main():\r\n    async with aiohttp.ClientSession() as session:\r\n        html = await fetch(session, \"http://httpbin.org/headers\")\r\n        print(html)\r\nasyncio.run(main())\r\ntasks=asyncio.ensure_future()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client.py b/client.py
--- a/client.py	(revision e27b689963a9f16e3f9e61693d73bf6ce1cdb90b)
+++ b/client.py	(date 1632394776919)
@@ -1,13 +1,25 @@
 import aiohttp
 import asyncio
 
-async def fetch(session, url):
-    async with session.get(url) as response:
-        return await response.text()
-
+# async def fetch(session, url):
+#     async with session.get(url) as response:
+#         return await response.text()
+#
+# async def main():
+#     async with aiohttp.ClientSession() as session:
+#         html = await fetch(session, "http://httpbin.org/headers")
+#         print(html)
+# asyncio.run(main())
+async def run(x):
+    for i in range(100):
+        return x
 async def main():
-    async with aiohttp.ClientSession() as session:
-        html = await fetch(session, "http://httpbin.org/headers")
-        print(html)
+    tasks=[run(x) for x in [1,2,3,4,5,6]]
+    a=await asyncio.gather(*tasks)
+    print(a)
+async def main1():
+    tasks=[run(x) for x in [1,2,3,4,5,6]]
+    a=await asyncio.gather(*tasks)
+    print(a)
 asyncio.run(main())
-tasks=asyncio.ensure_future()
\ No newline at end of file
+asyncio.run(main1())
\ No newline at end of file
